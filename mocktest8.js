var questions = [
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "Which scenario requires the use of `@future(callout=true)`?",
        "options": [
            "Scheduling Apex in future",
            "Performing DML after callout",
            "Making HTTP callouts asynchronously",
            "Invoking flows from Apex"
        ],
        "correct": 2,
        "explanation": "`@future(callout=true)` enables asynchronous callouts from Apex."
    },
    {
        "question": "What is the result of performing a DML operation on a list with partial failures in Apex?",
        "options": [
            "All records succeed",
            "All records fail",
            "Successful records are committed, others are rolled back",
            "An exception is thrown and none are committed"
        ],
        "correct": 2,
        "explanation": "Using Database methods like `Database.insert(records, false)` allows partial success with result tracking."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "In what scenario would you use a `Queueable` over a `Future` method?",
        "options": [
            "Need to make a callout",
            "Need to return a value",
            "Need to chain jobs and monitor state",
            "Need to send emails"
        ],
        "correct": 2,
        "explanation": "`Queueable` Apex supports job chaining and better control over asynchronous processing."
    },
    {
        "question": "What will happen if a Process Builder and a Before Trigger both update the same field?",
        "options": [
            "Process Builder takes precedence",
            "Trigger overrides the Process Builder",
            "Last one executed wins",
            "Salesforce throws a conflict error"
        ],
        "correct": 2,
        "explanation": "The last automation executed will override previous changes if updating the same field."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "What happens if a tracked property is updated in LWC?",
        "options": [
            "No change unless refreshed manually",
            "It rerenders the DOM automatically",
            "It updates after 5 seconds",
            "It breaks component state"
        ],
        "correct": 1,
        "explanation": "Tracked properties in LWC cause the component to re-render when their value changes."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "How would you conditionally render a block in LWC only when a list has data?",
        "options": [
            "Use an if:true directive on <template>",
            "Use a ternary operator",
            "Use a JavaScript if statement in markup",
            "Use lwc:if"
        ],
        "correct": 0,
        "explanation": "`<template if:true={property}>` is the correct syntax for conditional rendering in LWC."
    },
    {
        "question": "What is a Test.startTest() / Test.stopTest() block used for?",
        "options": [
            "Inserting test data",
            "Resetting governor limits",
            "Running asynchronous jobs only",
            "Setting batch size"
        ],
        "correct": 1,
        "explanation": "`Test.startTest()` resets governor limits to ensure fair testing and allows testing async code."
    },
    {
        "question": "Which statement is true about test data in Apex test classes?",
        "options": [
            "All standard data is available",
            "Data is rolled back at end of test",
            "You must insert actual Account data",
            "Data persists unless deleted"
        ],
        "correct": 1,
        "explanation": "Test data is rolled back automatically after test execution."
    },
    {
        "question": "What is a Test.startTest() / Test.stopTest() block used for?",
        "options": [
            "Inserting test data",
            "Resetting governor limits",
            "Running asynchronous jobs only",
            "Setting batch size"
        ],
        "correct": 1,
        "explanation": "`Test.startTest()` resets governor limits to ensure fair testing and allows testing async code."
    },
    {
        "question": "Which statement is true about test data in Apex test classes?",
        "options": [
            "All standard data is available",
            "Data is rolled back at end of test",
            "You must insert actual Account data",
            "Data persists unless deleted"
        ],
        "correct": 1,
        "explanation": "Test data is rolled back automatically after test execution."
    },
    {
        "question": "Which statement is true about test data in Apex test classes?",
        "options": [
            "All standard data is available",
            "Data is rolled back at end of test",
            "You must insert actual Account data",
            "Data persists unless deleted"
        ],
        "correct": 1,
        "explanation": "Test data is rolled back automatically after test execution."
    },
    {
        "question": "What is a Test.startTest() / Test.stopTest() block used for?",
        "options": [
            "Inserting test data",
            "Resetting governor limits",
            "Running asynchronous jobs only",
            "Setting batch size"
        ],
        "correct": 1,
        "explanation": "`Test.startTest()` resets governor limits to ensure fair testing and allows testing async code."
    },
    {
        "question": "What is a Test.startTest() / Test.stopTest() block used for?",
        "options": [
            "Inserting test data",
            "Resetting governor limits",
            "Running asynchronous jobs only",
            "Setting batch size"
        ],
        "correct": 1,
        "explanation": "`Test.startTest()` resets governor limits to ensure fair testing and allows testing async code."
    },
    {
        "question": "Which statement is true about test data in Apex test classes?",
        "options": [
            "All standard data is available",
            "Data is rolled back at end of test",
            "You must insert actual Account data",
            "Data persists unless deleted"
        ],
        "correct": 1,
        "explanation": "Test data is rolled back automatically after test execution."
    },
    {
        "question": "What is a Test.startTest() / Test.stopTest() block used for?",
        "options": [
            "Inserting test data",
            "Resetting governor limits",
            "Running asynchronous jobs only",
            "Setting batch size"
        ],
        "correct": 1,
        "explanation": "`Test.startTest()` resets governor limits to ensure fair testing and allows testing async code."
    }
];