var questions = [
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "How can a developer ensure proper sharing enforcement when querying in Apex?",
        "options": [
            "Using with sharing keyword",
            "Using without sharing keyword",
            "Using Security.stripInaccessible()",
            "Using System.runAs()"
        ],
        "correct": 2,
        "explanation": "`Security.stripInaccessible()` enforces field-level and object-level security in Apex queries."
    },
    {
        "question": "Which governor limit is most likely to be hit when querying related objects in a loop?",
        "options": [
            "Heap size limit",
            "SOQL query limit",
            "DML statement limit",
            "CPU time limit"
        ],
        "correct": 1,
        "explanation": "Placing SOQL queries inside loops can exceed the limit of 100 queries per transaction."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "Which automation tool allows looping over multiple related child records?",
        "options": [
            "Validation Rules",
            "Workflow Rules",
            "Flows",
            "Assignment Rules"
        ],
        "correct": 2,
        "explanation": "Flows provide looping capabilities which other declarative tools do not."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "What happens if a record update in a before trigger causes the same trigger to execute again?",
        "options": [
            "It recursively re-executes indefinitely",
            "It throws an error automatically",
            "Recursion must be prevented manually",
            "Salesforce blocks the trigger"
        ],
        "correct": 2,
        "explanation": "Triggers are not recursive by default, but manual logic must be implemented to prevent it."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "How can you prevent default form submission in an LWC?",
        "options": [
            "event.preventDefault()",
            "event.cancel()",
            "event.stopPropagation()",
            "form.prevent()"
        ],
        "correct": 0,
        "explanation": "`event.preventDefault()` stops the form from performing a full page reload."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "What is the role of `@track` in Lightning Web Components?",
        "options": [
            "It binds a property to the UI",
            "It enables reactive rendering",
            "It makes methods public",
            "It declares private variables"
        ],
        "correct": 1,
        "explanation": "`@track` marks properties as reactive for re-rendering when their values change."
    },
    {
        "question": "How can you test asynchronous Apex like Queueable?",
        "options": [
            "Using Future methods",
            "Enqueue from a batch class",
            "Test.startTest and Test.stopTest",
            "Use system log"
        ],
        "correct": 2,
        "explanation": "Asynchronous Apex should be tested within Test.startTest/stopTest blocks to ensure execution."
    },
    {
        "question": "How can you test asynchronous Apex like Queueable?",
        "options": [
            "Using Future methods",
            "Enqueue from a batch class",
            "Test.startTest and Test.stopTest",
            "Use system log"
        ],
        "correct": 2,
        "explanation": "Asynchronous Apex should be tested within Test.startTest/stopTest blocks to ensure execution."
    },
    {
        "question": "What\u2019s a best practice for testing Apex triggers?",
        "options": [
            "Use seeAllData=true",
            "Use mock callouts",
            "Use Test.startTest and Test.stopTest",
            "Directly modify production data"
        ],
        "correct": 2,
        "explanation": "`Test.startTest()` and `Test.stopTest()` should be used to isolate and test specific trigger logic."
    },
    {
        "question": "How can you test asynchronous Apex like Queueable?",
        "options": [
            "Using Future methods",
            "Enqueue from a batch class",
            "Test.startTest and Test.stopTest",
            "Use system log"
        ],
        "correct": 2,
        "explanation": "Asynchronous Apex should be tested within Test.startTest/stopTest blocks to ensure execution."
    },
    {
        "question": "What\u2019s a best practice for testing Apex triggers?",
        "options": [
            "Use seeAllData=true",
            "Use mock callouts",
            "Use Test.startTest and Test.stopTest",
            "Directly modify production data"
        ],
        "correct": 2,
        "explanation": "`Test.startTest()` and `Test.stopTest()` should be used to isolate and test specific trigger logic."
    },
    {
        "question": "What\u2019s a best practice for testing Apex triggers?",
        "options": [
            "Use seeAllData=true",
            "Use mock callouts",
            "Use Test.startTest and Test.stopTest",
            "Directly modify production data"
        ],
        "correct": 2,
        "explanation": "`Test.startTest()` and `Test.stopTest()` should be used to isolate and test specific trigger logic."
    },
    {
        "question": "How can you test asynchronous Apex like Queueable?",
        "options": [
            "Using Future methods",
            "Enqueue from a batch class",
            "Test.startTest and Test.stopTest",
            "Use system log"
        ],
        "correct": 2,
        "explanation": "Asynchronous Apex should be tested within Test.startTest/stopTest blocks to ensure execution."
    },
    {
        "question": "What\u2019s a best practice for testing Apex triggers?",
        "options": [
            "Use seeAllData=true",
            "Use mock callouts",
            "Use Test.startTest and Test.stopTest",
            "Directly modify production data"
        ],
        "correct": 2,
        "explanation": "`Test.startTest()` and `Test.stopTest()` should be used to isolate and test specific trigger logic."
    },
    {
        "question": "How can you test asynchronous Apex like Queueable?",
        "options": [
            "Using Future methods",
            "Enqueue from a batch class",
            "Test.startTest and Test.stopTest",
            "Use system log"
        ],
        "correct": 2,
        "explanation": "Asynchronous Apex should be tested within Test.startTest/stopTest blocks to ensure execution."
    }
];